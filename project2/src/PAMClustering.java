import java.util.ArrayList;
import java.util.Arrays;

public class PAMClustering {
    // Contains methods for partitioning a dataset into clusters and returning their centroids
    private int k;  // defines the number of clusters/centroids to calculate
    private int numAttributes;
    private ArrayList<Node> dataset;    // original dataset
    private ArrayList<Node> medoids;  // list of centroids generated by kmeans
    private ArrayList<ArrayList<Node>> clusters;    // contains lists of each current cluster
    private int maxIterations = 30; // defines the maximum number of times to try to iterate through swapping

    // remove this
    public boolean emptyClusterCreated = false;

    public PAMClustering(int k, ArrayList<Node> dataset) {
        // Constructs the class, automatically divides dataset into k clusters
        this.k = k;
        this.numAttributes = dataset.get(1).getData().length;   // saves number of attributes to be reinitialized later
        this.dataset = dataset;                                 // save original dataset
        this.medoids = pickRandomMedoids();             // generate centroids by picking random data points from the dataset
        boolean stopIteration = false;  // Flag to indicate when to stop looping through the assign-shift steps

        assignClusters();                              // assign clusters based on medoids
        changeMedoids();              // shift medoids based on clusters until they don't change
    }

    private ArrayList<Node> pickRandomMedoids() {
        // helper method picks random medoids by picking random data points
        ArrayList<Node> newMedoids = new ArrayList<>();
        ArrayList<Integer> pickedIndices = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            float[] data = new float[numAttributes];
            int dataIndex = (int)(Math.random()*dataset.size());
            while (pickedIndices.contains(dataIndex)) {
                // do not pick duplicates
                dataIndex = (int)(Math.random()*dataset.size());    // generate index until there's no repeat
            }
            pickedIndices.add(dataIndex);   // add to list of picked indices

            newMedoids.add(dataset.get(dataIndex));  // add new centroid to list of centroids
        }
        return newMedoids;
    }

    private void assignClusters() {
        // assigns points in the datasets to clusters centered around the current centroids
        // create k cluster arraylists
        this.clusters = new ArrayList<>();   // initialize new clusters

        for (int i = 0; i < k; i++) {
            // create new cluster lists
            clusters.add(new ArrayList<>());
        }

        // assign points to clusters - same for kmeans and kmedoids
        for (Node point : dataset) {
            float minDistance = Float.POSITIVE_INFINITY;    // first distance should be infinite
            int minClusterIndex = -1; //initialize variable to save cluster index. Will be assigned a positive index
            for (int i = 0; i < medoids.size(); i++) {
                float d = dist(point.getData(), medoids.get(i).getData());    // calculate Euclidean distance
                if (d < minDistance) {
                    // check if the distance between point and centroid is less than with other centroids calculated
                    minDistance = d;
                    minClusterIndex = i;   // assign new cluster index for minimum
                }
            }
            clusters.get(minClusterIndex).add(point);   // assign point to cluster
        }
        System.out.println("Checking for empty clusters...");
        for (int i = 0; i < medoids.size(); i++) {
            if (clusters.get(i).size() == 0) {
                System.out.println("Empty cluster found. Re-adding nearest point");
                emptyClusterCreated = true;

                float minDistance = Float.POSITIVE_INFINITY;    // infinite distance
                Node closestPoint = dataset.get(0);     // indicates current nearest point to previous medoid
                                                        // placeholder is the 0th, should get replaced in next loop

                Node medoid = medoids.get(i);               // stores medoid to test distance against
                for (Node point : dataset) {
                    // iterate through all points, store the closest point
                    float d = dist(point.getData(), medoid.getData());
                    if (d < minDistance) {
                        minDistance = d;
                        closestPoint = point;
                    }
                }
                clusters.get(i).add(closestPoint);
            }
        }
    }

    private void changeMedoids() {
        // changes the medoids for each clusters based on the point with minimum distance to the others
        // flag to indicate if the medoids have been moved
        float minTotalCost = calculateTotalCost();


        for (int i = 0; i < k; i++) {
            System.out.println("Iteration: " + i);
            for(Node node : dataset)
            {
                // loop through whole dataset, replacing medoid with the point and recalculating costs
                Node oldMedoid = medoids.get(i);    // store old medoid in case of swap back
                medoids.set(i, node); // swap medoid
                assignClusters();                           // reassign clusters
                float newTotalCost = calculateTotalCost();  // calculate the total cost from this
        
                if(!(newTotalCost < minTotalCost))
                {
                    // if the new total cost is not better than the old, swap back
                    medoids.set(i, oldMedoid);
                }
                else
                {
                    // else, save the new total cost
                    minTotalCost = newTotalCost;
                }
            }
        }
        assignClusters();   // reassign clusters in case a medoid has been swapped back on the last iteration
    }

    private float calculateTotalCost() {
        // calculates the total cost of all the clusters
        float totalCost = 0;
        for (int i = 0; i < k; i++) {
            // sum together distances for every cluster's points and its medoid
            Node medoid = medoids.get(i);
            for (Node point : clusters.get(i)) {
                // sum the distance between medoid and every other point in cluster. The same point should have distance 0
                totalCost += dist(point.getData(), medoid.getData());
            }
        }

        return totalCost;
    }

    private float dist(float[] a1, float[] a2) {
        // helper method to calculate euclidean distance squared between two attribute arrays
        float sum = 0;
        for (int i = 0; i < numAttributes; i++) {
            sum += Math.pow((a1[i] - a2[i]), 2);
        }
        return sum;
    }

    public ArrayList<Node> getMedoids() {
        // returns list of centroids **maybe approximates it to the kmeans
        return medoids;
    }

    public ArrayList<ArrayList<Node>> getClusters() {
        // returns list of clusters containing datapoints
        return clusters;
    }
}
