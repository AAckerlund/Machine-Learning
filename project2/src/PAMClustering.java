import java.io.FileNotFoundException;
import java.util.ArrayList;

public class PAMClustering {
    // Contains methods for partitioning a dataset into clusters and returning their centroids
    private final int k;  // defines the number of clusters/centroids to calculate
    private final int numAttributes;
    private final ArrayList<Node> dataset;    // original dataset
    private final ArrayList<Node> medoids;  // list of centroids generated by kmeans
    private ArrayList<ArrayList<Node>> clusters;    // contains lists of each current cluster

    public PAMClustering(int k, ArrayList<Node> dataset) throws FileNotFoundException
    {
        // Constructs the class, automatically divides dataset into k clusters
        this.k = k;
        this.numAttributes = dataset.get(1).getData().length;   // saves number of attributes to be reinitialized later
        this.dataset = dataset;                                 // save original dataset
        this.medoids = pickRandomMedoids();             // generate centroids by picking random data points from the dataset

        assignClusters();                              // assign clusters based on medoids
        changeMedoids();              // shift medoids based on clusters until they don't change
    }

    private ArrayList<Node> pickRandomMedoids() {
        // helper method picks random medoids by picking random data points
        ArrayList<Node> newMedoids = new ArrayList<>();
        ArrayList<Integer> pickedIndices = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            int dataIndex = (int)(Math.random()*dataset.size());
            while (pickedIndices.contains(dataIndex)) {
                // do not pick duplicates
                dataIndex = (int)(Math.random()*dataset.size());    // generate index until there's no repeat
            }
            pickedIndices.add(dataIndex);   // add to list of picked indices
            newMedoids.add(dataset.get(dataIndex));  // add new centroid to list of centroids
        }
        return newMedoids;
    }

    private void assignClusters() {
        // assigns points in the datasets to clusters centered around the current centroids
        // create k cluster arraylists
        this.clusters = new ArrayList<>();   // initialize new clusters

        for (int i = 0; i < k; i++) {
            // create new cluster lists
            clusters.add(new ArrayList<>());
        }

        // assign points to clusters - same for kmeans and kmedoids
        for (Node point : dataset) {
            float minDistance = Float.POSITIVE_INFINITY;    // first distance should be infinite
            int minClusterIndex = -1; //initialize variable to save cluster index. Will be assigned a positive index
            for (int i = 0; i < medoids.size(); i++) {
                float d = Calc.dist(point.getData(), medoids.get(i).getData(), point.getIgnoredAttr());    // calculate Euclidean distance
                if (d < minDistance) {
                    // check if the distance between point and centroid is less than with other centroids calculated
                    minDistance = d;
                    minClusterIndex = i;   // assign new cluster index for minimum
                }
            }
            clusters.get(minClusterIndex).add(point);   // assign point to cluster
        }
        for (int i = 0; i < medoids.size(); i++) {
            if (clusters.get(i).size() == 0) {

                float minDistance = Float.POSITIVE_INFINITY;    // infinite distance
                Node closestPoint = dataset.get(0);     // indicates current nearest point to previous medoid
                                                        // placeholder is the 0th, should get replaced in next loop

                Node medoid = medoids.get(i);               // stores medoid to test distance against
                for (Node point : dataset) {
                    // iterate through all points, store the closest point
                    float d = Calc.dist(point.getData(), medoid.getData(), point.getIgnoredAttr());
                    if (d < minDistance) {
                        minDistance = d;
                        closestPoint = point;
                    }
                }
                clusters.get(i).add(closestPoint);
            }
        }
    }

    private void changeMedoids() throws FileNotFoundException
    {
        // changes the medoids for each clusters based on the point with minimum distance to the others
        // Loops until medoids don't change anymore
        boolean medoidsChanged = true;   // flag to indicate if the medoids have been moved
        float minTotalCost = calculateTotalCost();

        int iterations = 0;
    
        // defines the maximum number of times to try to iterate through swapping
        int maxIterations = 4;
        while (medoidsChanged && iterations < maxIterations) {
            // run while medoids are changed and we are under the maximum number of iterations
            System.out.println("Iteration: " + iterations);
            iterations++;
            medoidsChanged = false;
            for (int i = 0; i < k; i++) {
                //System.out.println("Iteration: " + i);
                for(Node node : dataset)
                {
                    // loop through whole dataset, replacing medoid with the point and recalculating costs
                    Node oldMedoid = medoids.get(i);    // store old medoid in case of swap back
                    medoids.set(i, node); // swap medoid
                    float newTotalCost = calculateTotalCost();  // calculate the total cost from this
        
                    if(!(newTotalCost < minTotalCost))
                    {
                        // if the new total cost is not better than the old, swap back
                        medoids.set(i, oldMedoid);
                    }
                    else
                    {
                        // else, save the new total cost
                        minTotalCost = newTotalCost;
                        medoidsChanged = true;
                    }
                }
            }
            assignClusters();   // reassign clusters in case a medoid has been swapped back on the last iteration
        }
    }

    private float calculateTotalCost() {
        // calculates the total cost of all the clusters
        float totalCost = 0;
        for (int i = 0; i < k; i++) {
            // sum together distances for every cluster's points and its medoid
            Node medoid = medoids.get(i);
            for (Node point : clusters.get(i)) {
                // sum the distance between medoid and every other point in cluster. The same point should have distance 0
                totalCost += Calc.dist(point.getData(), medoid.getData(), point.getIgnoredAttr());
            }
        }
        return totalCost;
    }

    public ArrayList<Node> getMedoids() {
        // returns list of centroids **maybe approximates it to the kmeans
        return medoids;
    }

    public ArrayList<ArrayList<Node>> getClusters() {
        // returns list of clusters containing datapoints
        return clusters;
    }
}
