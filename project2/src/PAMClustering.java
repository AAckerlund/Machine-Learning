import java.util.ArrayList;
import java.util.Arrays;

public class PAMClustering {
    // Contains methods for partitioning a dataset into clusters and returning their centroids
    private int k;  // defines the number of clusters/centroids to calculate
    private int numAttributes;
    private ArrayList<Node> dataset;    // original dataset
    private ArrayList<Node> medoids;  // list of centroids generated by kmeans
    private ArrayList<ArrayList<Node>> clusters;    // contains lists of each current cluster

    // remove this
    public boolean emptyClusterCreated = false;

    public PAMClustering(int k, ArrayList<Node> dataset) {
        // Constructs the class, automatically divides dataset into k clusters
        this.k = k;
        this.numAttributes = dataset.get(1).getData().length;   // saves number of attributes to be reinitialized later
        this.dataset = dataset;                                 // save original dataset
        this.medoids = pickRandomMedoids();             // generate centroids by picking random data points from the dataset
        boolean stopIteration = false;  // Flag to indicate when to stop looping through the assign-shift steps

        // Loop these for a certain number of repetitions based on convergence
        int count = 0;  // keep track of number of loops
        while (!stopIteration) {
            System.out.println("Iteration: " + count);
            assignClusters();                              // assign clusters based on medoids
            stopIteration = !changeMedoids();              // shift medoids based on clusters until they don't change
            count++;
        }
    }

    private ArrayList<Node> pickRandomMedoids() {
        // helper method picks random medoids by picking random data points
        ArrayList<Node> newMedoids = new ArrayList<>();
        ArrayList<Integer> pickedIndices = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            float[] data = new float[numAttributes];
            int dataIndex = (int)(Math.random()*dataset.size());
            while (pickedIndices.contains(dataIndex)) {
                // do not pick duplicates
                dataIndex = (int)(Math.random()*dataset.size());    // generate index until there's no repeat
            }
            pickedIndices.add(dataIndex);   // add to list of picked indices

            newMedoids.add(dataset.get(dataIndex));  // add new centroid to list of centroids
        }
        return newMedoids;
    }

    private void assignClusters() {
        // assigns points in the datasets to clusters centered around the current centroids
        // create k cluster arraylists
        this.clusters = new ArrayList<>();   // initialize new clusters

        for (int i = 0; i < k; i++) {
            // create new cluster lists
            clusters.add(new ArrayList<>());
        }

        // assign points to clusters - same for kmeans and kmedoids
        for (Node point : dataset) {
            float minDistance = Float.POSITIVE_INFINITY;    // first distance should be infinite
            int minClusterIndex = -1; //initialize variable to save cluster index. Will be assigned a positive index
            for (int i = 0; i < medoids.size(); i++) {
                float d = dist(point.getData(), medoids.get(i).getData());    // calculate Euclidean distance
                if (d < minDistance) {
                    // check if the distance between point and centroid is less than with other centroids calculated
                    minDistance = d;
                    minClusterIndex = i;   // assign new cluster index for minimum
                }
            }
            clusters.get(minClusterIndex).add(point);   // assign point to cluster
        }
        for (int i = 0; i < medoids.size(); i++) {
            // It should not be possible for a medoid to be empty since each medoid is within the dataset
            if (clusters.get(i).size() == 0) {
                System.out.println("Empty cluster found. Re-adding nearest point");
                emptyClusterCreated = true;

                float minDistance = Float.POSITIVE_INFINITY;    // infinite distance
                Node closestPoint = dataset.get(0);     // indicates current nearest point to previous medoid
                                                        // placeholder is the 0th, should get replaced in next loop

                Node medoid = medoids.get(i);               // stores medoid to test distance against
                for (Node point : dataset) {
                    // iterate through all points, store the closest point
                    float d = dist(point.getData(), medoid.getData());
                    if (d < minDistance) {
                        minDistance = d;
                        closestPoint = point;
                    }
                }
                clusters.get(i).add(closestPoint);
            }
        }
    }

    private boolean changeMedoids() {
        // changes the medoids for each clusters based on the point with minimum distance to the others
        boolean medoidsChanged = false;   // flag to indicate if the medoids have been moved
        for (int i = 0; i < k; i++) {
            Node medoid = calculateMedoid(clusters.get(i));

            if (!Arrays.equals(medoid.getData(), medoids.get(i).getData())) {
                // if the calculated medoid's values are not equal to the previous medoid, then it has changed
                medoidsChanged = true;
            }
            medoids.set(i, medoid);
        }
        return medoidsChanged;
    }

    private Node calculateMedoid(ArrayList<Node> cluster) {
        // calculates the medoids of a given cluster
        Node medoid = cluster.get(0); // placeholder, should change in next loop
        // go through each point and calculate the point with the least distance to any other point

        float minSumDist = Float.POSITIVE_INFINITY; // indicates the current minimum sum distance of a point from others
        for (Node point : cluster) {
            float sumDist = 0;
            for (Node otherPoint : cluster) {
                // sum the distance between point and every other point in cluster. The same point should have distance 0
                sumDist += dist(point.getData(), otherPoint.getData());
            }
            if (sumDist < minSumDist) {
                // assign lower distance medoid
                minSumDist = sumDist;
                medoid = point;
            }
        }

        return medoid;
    }

    private float dist(float[] a1, float[] a2) {
        // helper method to calculate euclidean distance squared between two attribute arrays
        float sum = 0;
        for (int i = 0; i < numAttributes; i++) {
            sum += Math.pow((a1[i] - a2[i]), 2);
        }
        return sum;
    }

    public ArrayList<Node> getMedoids() {
        // returns list of centroids **maybe approximates it to the kmeans
        return medoids;
    }

    public ArrayList<ArrayList<Node>> getClusters() {
        // returns list of clusters containing datapoints
        return clusters;
    }
}
