import java.util.ArrayList;
import java.util.Arrays;

public class KMeansClustering {
    // Contains methods for partitioning a dataset into clusters and returning their centroids
    private int k;  // defines the number of clusters/centroids to calculate
    private int numAttributes;
    private ArrayList<Node> dataset;    // original dataset
    private ArrayList<Node> centroids;  // list of centroids generated by kmeans
    private ArrayList<ArrayList<Node>> clusters;    // contains lists of each current cluster

    // remove this
    public boolean emptyClusterCreated = false;

    public KMeansClustering(int k, ArrayList<Node> dataset) {
        // Constructs the class, automatically divides dataset into k clusters
        this.k = k;
        this.numAttributes = dataset.get(1).getData().length;   // saves number of attributes to be reinitialized later
        this.dataset = dataset;                                 // save original dataset
        this.centroids = pickRandomCentroids();             // generate centroids by picking random data points from the dataset
        boolean stopIteration = false;  // Flag to indicate when to stop looping through the assign-shift steps

        // Loop these for a certain number of repetitions based on convergence
        int count = 0;  // keep track of number of loops
        while (!stopIteration) {
            System.out.println("Iteration: " + count);
            assignClusters();                                       // assign clusters based on centroids
            stopIteration = !shiftCentroids();                  // shift centroids based on cluster means
            count++;
        }
    }
    
    //Overloading the constructor so that dist can be called for Edited KNN
    public KMeansClustering(){}

    private ArrayList<Node> pickRandomCentroids() {
        // helper method generates new centroids at the beginning of the clustering process from picking random datapoints
        // This helps ensure that they are somewhere in the range of the dataset and each cluster has at least one point
        ArrayList<Node> newCentroids = new ArrayList<>();
        ArrayList<Integer> pickedIndices = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            float[] data = new float[numAttributes];
            int dataIndex = (int)(Math.random()*dataset.size());
            while (pickedIndices.contains(dataIndex)) {
                // do not pick duplicates
                dataIndex = (int)(Math.random()*dataset.size());
            }
            pickedIndices.add(dataIndex);

            for (int j = 0; j < numAttributes; j++) {
                // copy data over to new data array
                data[j] = dataset.get(dataIndex).getData()[j];
            }

            Node newNode = new Node(-1, data, -1);    // Create new node to represent centroid with ID -1
            newCentroids.add(newNode);  // add new centroid to list of centroids
        }
        return newCentroids;
    }

    private void assignClusters() {
        // assigns points in the datasets to clusters centered around the current centroids
        // create k cluster arraylists
        this.clusters = new ArrayList<>();   // initialize new clusters

        for (int i = 0; i < k; i++) {
            // create new cluster lists
            clusters.add(new ArrayList<>());
        }

        // assign points to clusters
        for (Node point : dataset) {
            float minDistance = Float.POSITIVE_INFINITY;    // first distance should be infinite
            int minClusterIndex = -1; //initialize variable to save cluster index. Will be assigned a positive index
            for (int i = 0; i < centroids.size(); i++) {
                float d = dist(point.getData(), centroids.get(i).getData());    // calculate Euclidean distance
                if (d < minDistance) {
                    // check if the distance between point and centroid is less than with other centroids calculated
                    minDistance = d;
                    minClusterIndex = i;   // assign new cluster index for minimum
                }
            }
            clusters.get(minClusterIndex).add(point);   // assign point to cluster
        }
        for (int i = 0; i < centroids.size(); i++) {
            // It is possible for a cluster to end up empty. To ensure that there are k clusters, the nearest point to
            // the clusters' previous centroids is automatically added to the empty clusters
            if (clusters.get(i).size() == 0) {
                System.out.println("Empty cluster found. Adding nearest point");
                emptyClusterCreated = true;

                float minDistance = Float.POSITIVE_INFINITY;    // infinite distance
                Node closestPoint = dataset.get(0);     // indicates current nearest point to previous centroid
                                                        // placeholder is the 0th, should get replaced in next loop

                Node centroid = centroids.get(i);               // stores centroid to test distance against
                for (Node point : dataset) {
                    // iterate through all points, store the closest point
                    float d = dist(point.getData(), centroid.getData());
                    if (d < minDistance) {
                        minDistance = d;
                        closestPoint = point;
                    }
                }
                clusters.get(i).add(closestPoint);
            }
        }
    }

    private boolean shiftCentroids() {
        // moves the centroids based on the means calculated for each new cluster
        boolean centroidsChanged = false;   // flag to indicate if the centroids have been moved
        for (int i = 0; i < k; i++) {
            float[] mean = calculateMean(clusters.get(i));

            if (!Arrays.equals(mean, centroids.get(i).getData())) {
                // if the calculated mean is not equal to the previous centroid, then it has shifted
                centroidsChanged = true;
            }
            centroids.get(i).setData(mean);
        }
        return centroidsChanged;
    }

    private float[] calculateMean(ArrayList<Node> cluster) {
        // calculates the mean values of a given cluster
        float[] mean = new float[numAttributes];
        // go through each attribute and calculate the mean
        for (int i = 0; i < numAttributes; i++) {
            float sum = 0;
            for (Node point : cluster) {
                // sum up values of i attribute
                sum += point.getData()[i];
            }
            sum = sum / cluster.size(); // calculate mean by dividing by size of cluster
            mean[i] = sum;  // assign mean for that attribute
            //System.out.println("Assigned " + sum + " to attribute " + i);
        }

        return mean;
    }

    public float dist(float[] a1, float[] a2) {
        // helper method to calculate euclidean distance squared between two attribute arrays
        float sum = 0;
        for (int i = 0; i < a1.length; i++) {
            sum += Math.pow((a1[i] - a2[i]), 2);
        }
        return sum;
    }

    public ArrayList<Node> getCentroids() {
        // returns list of centroids **maybe approximates it to the kmeans
        return centroids;
    }

    public ArrayList<ArrayList<Node>> getClusters() {
        // returns list of clusters containing datapoints
        return clusters;
    }
}
